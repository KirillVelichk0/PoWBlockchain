//
// Created by houdini on 25.10.2023.
//

#ifndef BLOCKCHAINCORE_ILOGGER_H
#define BLOCKCHAINCORE_ILOGGER_H

#include <cstdint>
#include <string>
#include <string_view>
#include <memory.h>
#include <boost/json.hpp>
#include <boost/stacktrace.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
namespace BlockChainCore {
/*! Перечисление, отображающие возможные уровни логов. Не все они обязаны обрабатываться вашим логгером,
* Однако разновидности даны все.
*/
    enum class LogTypeEnum {
        Trace, Debug, Info, Warn, Error, Fatal
    };

/*! \brief Структура, характеризующая отдельную запись в логах.
 * \details Структура LogPackage содержит следующий набор полей: \n
 * logType - отвечает за уровень записи \n
 * systemInfo - любая дополнительная информация о системе (timestamp вынесен отдельно) \n
 * timestamp - временная метка в формате Posix. Характеризует время, в которое был сгенерирован лог \n
 * message - сообщение об ошибке \n
 * context - любой дополнительный контекст об ошибке \n
 * sourceType - тип источника в формате строки. Самое щекотливое с точки зрения формата поле.
 * По умолчанию все логи от ядра генерируются с sourceType BlockChainCore.
 * Возможно, что данное поле вообще будет игнорироваться.
 * Однако, так как ваш логгер может работать не только с логами ядра, а ядро вообще ничего не должно знать о том, куда и как
 * оно логирует, данное поле было добавлено для возможности дополнительной кастомизации маршрутизации логов
 */
    struct LogPackage {
        LogTypeEnum logType;
        std::string_view systemInfo;
        boost::posix_time::ptime timestamp;
        std::string_view message;
        std::string_view context;
        std::string_view sourceType;
    };



/*! Интерфейс, с помощью которого осуществляется логирование.
 * Важно! Так как существуют различные виды логгеров по наличию или отсутствию перехвата ошибок и прочего, данный интерфейс
 * отвечает лишь за доставку данных до логгера. Следует учитывать, что экземпляр данного класса будет создан на саммых
 * ранних стадиях начала функционирования ядра и в дальнейшем редактированию не подлежит. Со всеми аварийными ситуациями
 * должен справляться сам механизм логирования. \n
 * Важно! Под капотом используется shared_ptr. В общем, нужно грамотно определить, как деструктор влияет на время жизни объекта.
 * (например, ресурсами объекта владеет go-шный логгер) \n
 * Для обеспечения потокобезопасности Logger не должен менять свои состояния во время работы, или же должен быть защищен
 * примитивами синхронизации.
 */
    class ILogger {
    public:
        virtual ~ILogger() = 0;

        virtual void Log(const LogPackage &log) = 0;
    };


    //! Логгер выключен, чилим.
    class DisabledLogger final: public ILogger{
    public:
        DisabledLogger() = default;
        ~DisabledLogger() override;
        void Log(const LogPackage &log) override;
    };


    /*! Запускается единожды в самом начале работы программы. НЕ потоко-безопасен!
     * Скорее всего, будет вызываться не явно, а через C api. (Использовать эту фукнцию, только если вы работаете с плюсами).
     * Можно вызвать только один раз. Последующие вызовы функция игнорирует.
     * @param logger - абстракция к некоторому реальному логгеру на произвольной платформе
     */
    void SetupLogger(std::shared_ptr<ILogger> logger);


    /*!
     * Класс для тестирования логгера. Использует RAII, подсовывая переданный логгер в Singleton и возвращая DisabledLogger
     * после уничтожения.
     * Так как используется синглтон, следует быть аккуратным при тестах при запуске тестов в параллельном режиме.
     * */
    class LoggerTester{
    public:
        LoggerTester(std::shared_ptr<ILogger> logger);
        ~LoggerTester();
    };




    /*! Функция, с помощью которой осуществляется логирование. Данная функция просто вызывает установленный логгер.
     * Если он потокобезопасен, то данная функция тоже.
     * @param log- набор информации о логе. Тип LogPackage.
     */
    void Log(const LogPackage &log);

}




#endif //BLOCKCHAINCORE_ILOGGER_H
